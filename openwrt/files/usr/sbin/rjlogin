#!/bin/sh

# RJLogin 自动登录脚本
# 从配置文件读取参数并执行curl登录

CONFIG_FILE="/etc/config/rjlogin"
LOG_FILE="/var/log/rjlogin.log"
LOCK_FILE="/var/run/rjlogin.lock"

# 日志函数
log_msg() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') $1" >> "$LOG_FILE"
    echo "$1"
}

# 清理函数
cleanup() {
    rm -f "$LOCK_FILE"
    exit $1
}

# 信号处理
trap 'cleanup 1' INT TERM

# 检查是否已有实例在运行
if [ -f "$LOCK_FILE" ]; then
    log_msg "错误: 另一个实例正在运行"
    exit 1
fi

# 创建锁文件
echo $$ > "$LOCK_FILE"

# 检查配置文件是否存在
if [ ! -f "$CONFIG_FILE" ]; then
    log_msg "错误: 配置文件 $CONFIG_FILE 不存在"
    cleanup 1
fi

# 从配置文件读取参数
ENABLE=$(uci -q get rjlogin.@server[0].enable)
USERNAME=$(uci -q get rjlogin.@server[0].username)
PASSWORD=$(uci -q get rjlogin.@server[0].password)
URL=$(uci -q get rjlogin.@server[0].url)
REFERER=$(uci -q get rjlogin.@server[0].referer)

# 检查是否启用
if [ "$ENABLE" != "1" ]; then
    log_msg "RJLogin未启用，退出"
    cleanup 0
fi

# 检查必要参数
if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
    log_msg "错误: 用户名或密码为空"
    cleanup 1
fi

if [ -z "$URL" ]; then
    log_msg "错误: 登录URL为空"
    cleanup 1
fi

# 设置默认值
[ -z "$REFERER" ] && REFERER="http://10.10.12.13/eportal/index.jsp"

# 检查网络连通性
log_msg "检查网络连通性..."
if ! ping -c 1 -W 5 10.10.12.13 >/dev/null 2>&1; then
    log_msg "错误: 无法连接到服务器 10.10.12.13"
    cleanup 1
fi

# 执行登录
log_msg "开始执行登录，用户名: $USERNAME"

# 构建curl命令，使用变量替换
CURL_CMD="curl -s -w '%{http_code}' \
    -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8' \
    --compressed \
    -H 'Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6' \
    -H 'Connection: keep-alive' \
    -b 'EPORTAL_COOKIE_OPERATORPWD=' \
    -H 'Origin: http://10.10.12.13' \
    -H 'Referer: $REFERER' \
    -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36 Edg/140.0.0.0' \
    --connect-timeout 10 \
    --max-time 30 \
    --data-binary 'userId=$USERNAME&password=$PASSWORD&service=%25E7%2594%25B5%25E4%25BF%25A1&queryString=wlanuserip%253D96d9e10e71f0e2d98428b0cebbe5b303%2526wlanacname%253Dd185bee1eeb6cce8f4b0c2630741f643%2526ssid%253D%2526nasip%253D5d508bf82308b1e8bf9ad964686976f7%2526snmpagentip%253D%2526mac%253Df633aa244f8b3fab1356681002c6c0f9%2526t%253Dwireless-v2%2526url%253D2c0328164651e2b4f13b933ddf36628bea622dedcc302b30%2526apmac%253D%2526nasid%253Dd185bee1eeb6cce8f4b0c2630741f643%2526vid%253D6b0c48187f7f5364%2526port%253Dc31b6bc13b559606%2526nasportid%253Df5eb983692924fa26e6431fe9df4835f9b478afd03e5624b1004e3c7bde9fca6f7d855c56394e4d3&operatorPwd=&operatorUserId=&validcode=&passwordEncrypt=false' \
    '$URL'"

# 执行curl命令
RESPONSE=$(eval "$CURL_CMD")
EXIT_CODE=$?

# 检查curl执行结果
if [ $EXIT_CODE -ne 0 ]; then
    log_msg "错误: curl命令执行失败，退出码: $EXIT_CODE"
    cleanup 1
fi

# 解析响应
if [ -n "$RESPONSE" ] && [ ${#RESPONSE} -ge 3 ]; then
    HTTP_CODE=${RESPONSE##*[^0-9]}
    if [ ${#HTTP_CODE} -eq 3 ] && [ "$HTTP_CODE" -eq "$HTTP_CODE" ] 2>/dev/null; then
        RESPONSE_BODY=${RESPONSE%$HTTP_CODE}
    else
        HTTP_CODE="000"
        RESPONSE_BODY="$RESPONSE"
    fi
else
    HTTP_CODE="000"
    RESPONSE_BODY="空响应"
fi

# 记录结果
if [ "$HTTP_CODE" = "200" ]; then
    log_msg "登录请求成功 (HTTP 200)"
    if echo "$RESPONSE_BODY" | grep -qi "success\|成功\|登录成功"; then
        log_msg "登录成功"
        cleanup 0
    elif echo "$RESPONSE_BODY" | grep -qi "error\|错误\|失败"; then
        log_msg "登录失败，响应: $RESPONSE_BODY"
        cleanup 1
    else
        log_msg "登录状态未知，响应: $RESPONSE_BODY"
        cleanup 0
    fi
else
    log_msg "登录请求失败，HTTP状态码: $HTTP_CODE"
    log_msg "响应内容: $RESPONSE_BODY"
    cleanup 1
fi